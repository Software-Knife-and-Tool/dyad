assert_eq "(mu:eq 1 1)" ":t"
assert_eq "(mu:eq 1 2)" ":nil"
assert_eq "(mu:eval 'mu:std-in)" "#<stream: id: 2147483648>"
assert_eq "(mu:eval ())" ":nil"
assert_eq "(mu:fix (:lambda (l) (:if l ((:lambda () (mu:write (mu:car l) () mu:std-out) (mu:cdr l))) ())) '(1 2 3 4))" "1234:nil"
assert_eq "(mu:fix (:lambda (l) (:if l ((:lambda () (mu:write (mu:car (mu:car l)) () mu:std-out) (mu:cdr l))) ())) '((0 . 1) (2 . 3)))" "02:nil"
assert_eq "(mu:apply mu:eq '(1 2))" ":nil"
assert_eq "(mu:apply mu:fx-add '(1 2))" "3"
assert_eq "(mu:type-of #\a)" ":char"
assert_eq "(mu:type-of '(1 2 3))" ":cons"
assert_eq "(mu:type-of '(:lambda ()))" ":cons"
assert_eq "(mu:type-of 'mu:apply)" ":symbol"
assert_eq "(mu:type-of ())" ":null"
assert_eq "(mu:type-of 1)" ":fixnum"
assert_eq "(mu:type-of :typeof)" ":keyword"
assert_eq "(mu:type-of mu:std-in)" ":stream"
assert_eq "(mu:type-of mu:hp-info)" ":func"
assert_eq "(mu:type-of mu:fr-get)" ":func"
assert_eq "(mu:type-of mu:fr-push)" ":func"
assert_eq "(mu:type-of mu:fr-pop)" ":func"
assert_eq '(mu:type-of "type-of")' ":vector"
assert_eq '(mu:view #\a)' "#S(:char a)"
assert_eq "(mu:view '(1 2))" "#S(:cons 1 (2))"
assert_eq '(mu:view 1234)' "#S(:fixnum 1234)"
assert_eq '(mu:view 1.0)' "#S(:float 1.0000)"
assert_eq "(mu:view #(:t 1 2))" "#S(:vector 2 :t)"
assert_eq "(mu:view #s(:foo 1 2))" "#S(:struct :foo #(:t 1 2))"
assert_eq "(mu:view 'a)" '#S(:symbol #<namespace: ""> :extern a :UNBOUND)'
assert_eq "(mu:view 'mu:eq)" '#S(:symbol #<namespace: "mu"> :extern eq #<:function :native [req:2, tag:eq]>)'
assert_eq '(mu:view (mu:map-ns "mu"))' "#S(:ns mu :nil)"
assert_eq "(mu:view mu:std-in)" "#S(:stream 2147483648 0 :input :nil :nil)"
assert_eq "(mu:with-ex (:lambda (cond obj) (mu:write cond () mu:std-out)) (:lambda () (mu:fx-div 1 1)))" "1"
